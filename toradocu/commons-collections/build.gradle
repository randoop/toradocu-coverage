/* commons-collections */

def libraryName = 'commons-collections'
def libraryJar = 'commons-collections4-4.2-SNAPSHOT.jar'
def repoURI = 'https://github.com/randoop/commons-collections.git'

def inputsDir = file("${projectDir}/inputs")
def resourceDirPath = "${projectDir}/resources"
def librarySrcDir = "${inputsDir}/${libraryName}/src/main/java"
def libraryJarPath = "${inputsDir}/${libraryName}/target/${libraryJar}"
def libraryScriptPath = "${inputsDir}/${libraryName}/pom.xml"

// common resources in top-level directory
def randoopJar = "${rootProject.projectDir}/libs/randoop.jar"

dependencies {
  testCompile files(libraryJarPath)
  testCompile group: 'junit', name: 'junit', version: '4.+'
  testCompile group: 'org.hamcrest', name: 'hamcrest-all', version: '1.3'
}

//--- build aliases : define a synonym here if you want a shortcut to run multiple targets
// Note that this is a 'trick' to enforce textual order on dependencies.

def buildAliases = [
  'prepareForRandoop'  : ['getClassList', 'compileInputs'],
  'prepareForCoverage' : ['cleanRandoop', 'cleanTest', 'runRandoop', 'compileTestJava']
]
def expandedTaskList = []

gradle.startParameter.taskNames.each {
  expandedTaskList << (buildAliases[it] ? buildAliases[it] : it)
}

gradle.startParameter.taskNames = expandedTaskList.flatten()

println "\nexpanded task list: ${gradle.startParameter.taskNames }\n"


/**** Tasks for managing a local copy of commons-collections ****/

/*
 * Download a copy of the project clone of commons-collections
 */
task getInputs {
  description 'Places source library for commons-collections in inputs directory'
  doLast {
    def libInputsDir = file("${inputsDir}/${libraryName}")
    if (!libInputsDir.exists()) {
      org.ajoberstar.grgit.Grgit.clone(dir: libInputsDir, uri: repoURI)
    } else {
      println("WARNING: not cloning repo because already exists.")
      println("         Force clone by running with cleanInputs")
    }
  }
}

/*
 * Compiles the commons-collections source files
 */
task compileInputs(type: Exec, dependsOn: getInputs) {
  description "Compile subject library"
  commandLine "mvn", "-f", libraryScriptPath, "-Dmaven.test.skip=true", "package"
  outputs.file(libraryJarPath)
}

task cleanCompileInputs(type: Exec) {
  description "Invokes clean task for subject library"
  commandLine "mvn", "-f", libraryScriptPath, "clean"
}

/*
 * Deletes files created by the `getInputs` task.
 */
task cleanInputs(type: Delete) {
  delete 'inputs'
}

task makeResourceDir() {
  def resourceDir = file("$resourceDirPath")
  outputs.dir { resourceDir}
  doLast() {
    if (!resourceDir.exists()) {
      file(resourceDir).mkdirs()
    }
  }
}

/*
 * Reads the main source directory of the commons-collections files in inputs,
 * and creates the class list input for Randoop and the `runToradocu` task.
 * Explicit excludes are used to avoid files that cause trouble for either
 * Toradocu or Randoop.
 */
task getClassList(dependsOn: [getInputs, makeResourceDir] ) {
  description "Creates the class list for evaluation (with exclusions)"
  def sources = fileTree(librarySrcDir) {
    include '**/*.java'
    exclude '**/package-info.java'
  }
  def classListFile = new File("${resourceDirPath}/classlist.txt")
  inputs.files(sources).skipWhenEmpty()
  outputs.file(classListFile)
  doLast() {
    def writer = classListFile.newWriter()
    def classnames = sources.files.collect {
      file ->
        def filename = file.canonicalPath - "${librarySrcDir}/"
        filename.replaceAll('/','.').replaceAll('.java','')
    }
    classnames.each {
      filename -> writer << filename + "\n"
    }
    writer.close()
  }
}

/*
 * Deletes the class list file generated by `getClassList`
 */
task cleanClassList(type: Delete) {
  delete "$resourceDirPath/classlist.txt"
}

/**** Randoop tasks ****/

task runRandoop(dependsOn: [getClassList, compileInputs]) {
  group 'test generation'
  description "Runs Randoop to first error test (or 15 minutes) on resources/evallist.txt"
  def inputClasspath = libraryJarPath
  def classpath = files(inputClasspath, randoopJar).asPath
  def cmd = "java -ea -cp ${classpath} randoop.main.Main gentests"
  def classListFile = file("$resourceDirPath/classlist.txt")
  def outputDir = "${projectDir}/src/test/java"
  def options = [
    "--classlist=${classListFile}",
    "--time-limit=900",
    "--stop-on-error-test=false",
    "--junit-output-dir=${outputDir}",
    "--flaky-test-behavior=output",
    "--no-error-revealing-tests",
    "--junit-reflection-allowed=false",
//    "--log=foo",
    "--usethreads",
//    "--omitmethods=${exclusions}",
    "--output-limit=2000"
  ]
  inputs.file(inputClasspath)
  inputs.file(classListFile)
  outputs.dir(file(outputDir))
  doLast {
    def classDirPath = "${inputsDir}/${libraryName}/target/classes"
    def dirListFile = new File("${resourceDirPath}/classdir.txt")
    def writerD = dirListFile.newWriter()
    writerD << classDirPath + "\n"
    writerD.close()
    def pathListFile = new File("${resourceDirPath}/classpath.txt")
    def writerP = pathListFile.newWriter()
    writerP << classpath + "\n"
    writerP.close()
    if (!file(outputDir).exists()) {
      file(outputDir).mkdirs()
    }
    project.exec {
      commandLine = cmd.split().toList() + options
      println(commandLine)
    }
  }
}

task cleanRandoop(type: Delete) {
  description 'Removes Randoop generated tests'
  delete fileTree('src/test/') {
    include '**/*.java'
  }
}

task cleanTest(type: Delete) {
  description 'Removes class files for Randoop generated tests'
  delete fileTree('build/classes/test/') {
    include '**/*.class'
  }
}

